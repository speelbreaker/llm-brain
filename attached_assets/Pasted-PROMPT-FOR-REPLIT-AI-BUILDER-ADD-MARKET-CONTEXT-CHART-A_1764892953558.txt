PROMPT FOR REPLIT AI BUILDER (ADD MARKET CONTEXT + CHART-AWARE LLM DECISIONS)

I have an existing Deribit options trading agent project with:

A background worker agent loop (LLM decision mode already working in “research, dry-run”).

AgentState model that includes portfolio + candidate options.

An LLM brain function like choose_action_with_llm(agent_state, candidates) that calls the OpenAI Responses API.

A backtesting module in src/backtest/ (already working, no need to touch now).

I want to upgrade the live agent so the LLM sees a compact market/“chart” context (trend/regime, recent returns, realized vol) and uses it when deciding to open/roll/close covered calls.

Please do the following changes carefully and consistently.

1. Add MarketContext to our models

In the shared models file (where AgentState is defined, e.g. src/models.py):

Add a MarketContext dataclass (or Pydantic model, matching existing style) with these fields:

from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Literal

@dataclass
class MarketContext:
    underlying: str
    time: datetime

    # Trend / regime
    regime: Literal["bull", "sideways", "bear"]
    pct_from_50d_ma: float
    pct_from_200d_ma: float

    # Recent performance (%)
    return_1d_pct: float
    return_7d_pct: float
    return_30d_pct: float

    # Realized volatility (annualized)
    realized_vol_7d: float
    realized_vol_30d: float

    # Optional support/resistance (can be None for now)
    support_level: Optional[float] = None
    resistance_level: Optional[float] = None
    distance_to_support_pct: Optional[float] = None
    distance_to_resistance_pct: Optional[float] = None


Extend AgentState to include an optional market_context field:

@dataclass
class AgentState:
    # existing fields...
    timestamp: datetime
    portfolio: dict
    candidate_options: list
    # ...other existing fields...

    market_context: Optional[MarketContext] = None


Adjust imports / types as needed to match the current style of AgentState (dataclass vs BaseModel).

2. Implement compute_market_context for BTC using the existing Deribit client

Create a new module src/market_context.py with a function that:

Uses our existing live Deribit client (the one used by the agent loop, not the backtest client).

Pulls ~60 days of daily OHLC data for the index instrument (e.g. "BTC_USDC").

Computes:

1d / 7d / 30d % returns

7d / 30d realized volatility (annualized)

Price distance from 50D and 200D moving averages

A simple regime label: "bull" | "sideways" | "bear".

Implementation guidelines:

# src/market_context.py
from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Literal, Optional

import numpy as np
import pandas as pd

from .models import MarketContext
from .deribit_client import DeribitClient  # use the client used by the live agent


def compute_market_context(
    client: DeribitClient,
    underlying: str,
    as_of: datetime,
) -> Optional[MarketContext]:
    """
    Build a compact 'chart-aware' summary for the LLM.
    Uses daily candles for the last ~60 days.
    """

    start = as_of - timedelta(days=60)

    # Use the same TradingView-style API wrapper the agent uses (or add one if missing).
    # It should be equivalent to public/get_tradingview_chart_data.
    # We assume a method `client.get_tradingview_chart_data(instrument_name, start, end, resolution)`
    res = client.get_tradingview_chart_data(
        instrument_name=f"{underlying}_USDC",  # index used as spot
        start=start,
        end=as_of,
        resolution="1D",
    )
    if not res["ticks"]:
        return None

    timestamps = [
        datetime.fromtimestamp(ts / 1000, tz=timezone.utc) for ts in res["ticks"]
    ]
    df = pd.DataFrame(
        {
            "close": res["close"],
        },
        index=pd.DatetimeIndex(timestamps, name="timestamp"),
    ).sort_index()

    if len(df) < 30:
        return None

    close = df["close"]

    # % returns (simple)
    def pct_return(days: int) -> float:
        if len(close) < days + 1:
            return 0.0
        c_now = close.iloc[-1]
        c_prev = close.iloc[-(days + 1)]
        return float((c_now / c_prev - 1.0) * 100.0)

    return_1d_pct = pct_return(1)
    return_7d_pct = pct_return(7)
    return_30d_pct = pct_return(30)

    # Realized vol (annualized) over last N days using log returns
    log_ret = np.log(close / close.shift(1)).dropna()

    def realized_vol(days: int) -> float:
        window = log_ret[-days:]
        if window.empty:
            return 0.0
        daily_vol = float(window.std())
        return float(daily_vol * np.sqrt(365.0))  # annualized

    realized_vol_7d = realized_vol(7)
    realized_vol_30d = realized_vol(30)

    # Moving averages
    ma_50 = float(close.rolling(window=50).mean().iloc[-1])
    ma_200 = float(
        close.rolling(window=200).mean().iloc[-1]
    ) if len(close) >= 200 else ma_50

    last = float(close.iloc[-1])
    pct_from_50d_ma = float((last / ma_50 - 1.0) * 100.0) if ma_50 > 0 else 0.0
    pct_from_200d_ma = float((last / ma_200 - 1.0) * 100.0) if ma_200 > 0 else 0.0

    # Simple regime classification
    if pct_from_200d_ma > 5.0 and return_30d_pct > 10.0:
        regime: Literal["bull", "sideways", "bear"] = "bull"
    elif pct_from_200d_ma < -5.0 and return_30d_pct < -10.0:
        regime = "bear"
    else:
        regime = "sideways"

    return MarketContext(
        underlying=underlying,
        time=as_of,
        regime=regime,
        pct_from_50d_ma=pct_from_50d_ma,
        pct_from_200d_ma=pct_from_200d_ma,
        return_1d_pct=return_1d_pct,
        return_7d_pct=return_7d_pct,
        return_30d_pct=return_30d_pct,
        realized_vol_7d=realized_vol_7d,
        realized_vol_30d=realized_vol_30d,
        support_level=None,
        resistance_level=None,
        distance_to_support_pct=None,
        distance_to_resistance_pct=None,
    )


If the live DeribitClient does not yet expose a get_tradingview_chart_data wrapper, please add one by reusing the logic from src/backtest/deribit_client.py, but calling the mainnet base URL and using the same httpx client style as the rest of the app.

3. Attach market_context when building AgentState

In the module that builds the agent state for the loop (often something like src/state_builder.py or the code just before calling the policy/LLM):

After you determine now and build portfolio and candidate_options, call:

from .market_context import compute_market_context

market_ctx = compute_market_context(
    client=deribit_client,   # the one used for live trading
    underlying="BTC",        # start with BTC as primary; ETH later if needed
    as_of=now,
)


When you instantiate AgentState, set the new field:

agent_state = AgentState(
    timestamp=now,
    portfolio=portfolio_dict,
    candidate_options=candidates,
    # ...other existing fields...
    market_context=market_ctx,
)


Make sure this runs in the live agent loop (the same AgentState that’s passed into both the rule-based policy and the LLM brain).

4. Update the LLM decision brain to include market_context in the JSON it sends to OpenAI

In src/agent_brain_llm.py (or equivalent), where choose_action_with_llm(state, candidates) is defined:

Add a helper to build the JSON payload sent to the Responses API:

from .config import settings
from .models import AgentState

def build_llm_decision_payload(
    state: AgentState,
    candidates_json: list[dict],
) -> dict:
    mc = state.market_context

    market_ctx_json = None
    if mc is not None:
        market_ctx_json = {
            "underlying": mc.underlying,
            "time": mc.time.isoformat(),
            "regime": mc.regime,
            "spot": state.portfolio.get("spot"),  # if you store spot here
            "pct_from_50d_ma": mc.pct_from_50d_ma,
            "pct_from_200d_ma": mc.pct_from_200d_ma,
            "return_1d_pct": mc.return_1d_pct,
            "return_7d_pct": mc.return_7d_pct,
            "return_30d_pct": mc.return_30d_pct,
            "realized_vol_7d": mc.realized_vol_7d,
            "realized_vol_30d": mc.realized_vol_30d,
            "support_level": mc.support_level,
            "resistance_level": mc.resistance_level,
            "distance_to_support_pct": mc.distance_to_support_pct,
            "distance_to_resistance_pct": mc.distance_to_resistance_pct,
        }

    payload = {
        "mode": settings.mode,
        "llm_enabled": settings.llm_enabled,
        "portfolio": state.portfolio,
        "market_context": market_ctx_json,
        "candidates": candidates_json,
        "risk_limits": {
            "max_margin_used_pct": settings.max_margin_used_pct,
            "max_net_delta_abs": settings.max_net_delta_abs,
            "max_expiry_exposure": settings.max_expiry_exposure,
        },
        "config": {
            "default_order_size": settings.default_order_size,
            "min_ivrv": settings.effective_ivrv_min,
        },
    }
    return payload


In choose_action_with_llm, serialize candidates into simple JSON-friendly dicts (if not already), call build_llm_decision_payload, and then pass this into the Responses API as input_json.

Example structure:

from openai import OpenAI

client = OpenAI()

LLM_DECISION_SYSTEM_PROMPT = """
You are an options trading agent managing covered calls on Deribit (testnet for now) for BTC and ETH.

You receive a JSON input with:
- portfolio: holdings, equity, margin usage.
- market_context: compact summary of recent price action and regime.
- candidates: possible options to trade (symbol, strike, DTE, delta, IV, IVRV, premium, etc.).
- risk_limits: hard constraints (max margin usage, max net delta, max expiry exposure).
- config: default order size and minimum IVRV.

Your job:
1. Propose ONE of the following actions:
   - DO_NOTHING
   - OPEN_COVERED_CALL
   - ROLL_COVERED_CALL
   - CLOSE_COVERED_CALL

2. Your JSON response MUST have exactly:
   {
     "action": "DO_NOTHING" | "OPEN_COVERED_CALL" | "ROLL_COVERED_CALL" | "CLOSE_COVERED_CALL",
     "params": { ... },
     "reasoning": "short explanation referencing the data you used"
   }

3. Respect risk limits strictly:
   - Never suggest a trade that would violate max_expiry_exposure, max_margin_used_pct, or max_net_delta_abs.
   - Never invent instrument symbols. Only use candidates or existing open positions.

4. Use the market_context in a simple, structured way:
   - If regime is "bull" AND 30-day return is strongly positive (e.g. > +15%) AND price is >5% above the 50-day MA:
       * Be more conservative with calls:
         - prefer lower deltas (further OTM),
         - avoid very short-dated aggressive calls unless IVRV is clearly high.
   - If regime is "bear" AND 30-day return is strongly negative (e.g. < -15%):
       * Prioritize capital preservation:
         - you may choose DO_NOTHING instead of opening new covered calls,
         - or sell smaller size / further OTM if IVRV is attractive.
   - If market_context shows a very recent dump (7-day return < -10%):
       * Be cautious about selling new calls immediately after the drop unless IVRV is substantially above the minimum and margin is comfortable.
   - If market_context shows sideways regime:
       * It is acceptable to be more assertive with covered calls within risk limits (moderate deltas and shorter DTE).

5. Use IVRV and premiums together with market_context:
   - Only open/roll calls when IVRV is at or above the configured minimum.
   - Between candidates, prefer those with a better balance of:
       * higher premium,
       * acceptable delta and DTE,
       * and lower risk of getting deep ITM given the current regime.

Be concise in reasoning but explicitly mention:
- The regime (bull/sideways/bear),
- Key return/vol metrics that influenced your choice,
- Why you picked this particular candidate or chose DO_NOTHING.
"""

def choose_action_with_llm(state: AgentState, candidates: list) -> dict:
    candidates_json = [c.to_jsonable() if hasattr(c, "to_jsonable") else c for c in candidates]
    payload = build_llm_decision_payload(state, candidates_json)

    response = client.responses.create(
        model=settings.llm_model_name,
        input=[
            {
                "role": "system",
                "content": LLM_DECISION_SYSTEM_PROMPT,
            },
            {
                "role": "user",
                "content": [
                    {
                        "type": "input_json",
                        "input_json": payload,
                    }
                ],
            },
        ],
        response_format={"type": "json_object"},
    )

    # Parse JSON from response and return dict with keys: action, params, reasoning.
    # Keep existing validation / fallback to DO_NOTHING if parsing fails.


Please keep all existing risk engine checks and dry-run logic unchanged. The only changes should be:

AgentState has market_context.

compute_market_context populates it.

LLM input payload includes market_context.

System prompt explains how to use those features.

5. (Optional for now) Backtest integration

Do not change the backtest module right now. Once the live agent is stable with market_context, we can later reuse a similar compute_market_context function on historical OHLC (from MarketDataSource) to add regime features into the (state, action, reward) training data.