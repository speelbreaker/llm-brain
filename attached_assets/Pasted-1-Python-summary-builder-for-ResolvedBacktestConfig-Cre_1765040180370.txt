1. Python: summary builder for ResolvedBacktestConfig

Create e.g. app/utils/rules_summary.py:

# app/utils/rules_summary.py

from typing import Any, Dict, List
from app.schemas.backtest import ResolvedBacktestConfig, BacktestPreset, BacktestMode


def _on_off(value: bool) -> str:
    return "ON" if value else "OFF"


def build_rules_summary(cfg: ResolvedBacktestConfig) -> Dict[str, Any]:
    """
    Turn a ResolvedBacktestConfig into a UI-friendly summary structure
    that templates can render as a box with sections and badges.
    """

    t = cfg.thresholds
    r = cfg.rule_toggles

    # Human-friendly labels for mode/preset
    mode_label = "Training mode" if cfg.mode == BacktestMode.TRAINING else "Live mode"

    preset_map = {
        BacktestPreset.ULTRA_SAFE: "Ultra Safe",
        BacktestPreset.BALANCED: "Balanced",
        BacktestPreset.AGGRESSIVE: "Aggressive",
        BacktestPreset.CUSTOM: "Custom (manual overrides)",
    }
    preset_label = preset_map.get(cfg.preset, cfg.preset.value)

    # Headline & subtitle
    headline = f"{mode_label} · {preset_label}"

    subtitle_parts: List[str] = []

    if t.max_margin_used_pct is not None:
        subtitle_parts.append(f"Max margin: {t.max_margin_used_pct:.0f}%")
    if t.max_net_delta_abs is not None:
        subtitle_parts.append(f"Max |net delta|: {t.max_net_delta_abs:.2f}")
    if t.delta_range is not None:
        subtitle_parts.append(
            f"Delta range: {t.delta_range[0]:.2f} – {t.delta_range[1]:.2f}"
        )
    if t.dte_range is not None:
        subtitle_parts.append(
            f"DTE range: {t.dte_range[0]}–{t.dte_range[1]} days"
        )

    subtitle = " · ".join(subtitle_parts)

    # Badges (for top of the box)
    badges: List[Dict[str, str]] = []

    badges.append(
        {
            "label": "Mode",
            "value": cfg.mode.value,
        }
    )
    badges.append(
        {
            "label": "Preset",
            "value": cfg.preset.value,
        }
    )

    if r.enforce_margin_cap is not None:
        badges.append(
            {
                "label": "Margin cap",
                "value": _on_off(r.enforce_margin_cap),
            }
        )
    if r.enforce_net_delta_cap is not None:
        badges.append(
            {
                "label": "Delta cap",
                "value": _on_off(r.enforce_net_delta_cap),
            }
        )
    if r.require_ivrv_filter is not None:
        badges.append(
            {
                "label": "IV/RV filter",
                "value": _on_off(r.require_ivrv_filter),
            }
        )

    # Sections
    sections: List[Dict[str, Any]] = []

    # 1) Risk limits
    risk_items: List[Dict[str, str]] = []
    if r.enforce_margin_cap is not None:
        risk_items.append(
            {
                "label": "Enforce margin usage cap",
                "value": _on_off(r.enforce_margin_cap),
                "detail": (
                    f"Max margin used: {t.max_margin_used_pct:.0f}%"
                    if t.max_margin_used_pct is not None
                    else ""
                ),
            }
        )
    if r.enforce_net_delta_cap is not None:
        risk_items.append(
            {
                "label": "Enforce net delta cap",
                "value": _on_off(r.enforce_net_delta_cap),
                "detail": (
                    f"Max |net delta|: {t.max_net_delta_abs:.2f}"
                    if t.max_net_delta_abs is not None
                    else ""
                ),
            }
        )
    if r.enforce_per_expiry_exposure is not None:
        risk_items.append(
            {
                "label": "Per-expiry exposure cap",
                "value": _on_off(r.enforce_per_expiry_exposure),
                "detail": (
                    f"Cap: {t.per_expiry_exposure_cap:.2f}"
                    if t.per_expiry_exposure_cap is not None
                    else ""
                ),
            }
        )

    if risk_items:
        sections.append(
            {
                "title": "Risk limits",
                "items": risk_items,
            }
        )

    # 2) Trade selection filters
    filter_items: List[Dict[str, str]] = []

    if r.require_ivrv_filter is not None:
        filter_items.append(
            {
                "label": "Require IV/RV filter",
                "value": _on_off(r.require_ivrv_filter),
                "detail": (
                    f"Min IV/RV: {t.min_ivrv:.2f}"
                    if t.min_ivrv is not None
                    else ""
                ),
            }
        )

    if t.delta_range is not None:
        filter_items.append(
            {
                "label": "Delta band",
                "value": f"{t.delta_range[0]:.2f} – {t.delta_range[1]:.2f}",
                "detail": "Target short-call deltas",
            }
        )

    if t.dte_range is not None:
        filter_items.append(
            {
                "label": "DTE band",
                "value": f"{t.dte_range[0]}–{t.dte_range[1]} days",
                "detail": "Target time to expiry",
            }
        )

    if r.respect_min_premium_filter is not None:
        filter_items.append(
            {
                "label": "Min premium filter",
                "value": _on_off(r.respect_min_premium_filter),
                "detail": (
                    f"Min premium: ${t.min_premium_usd:.0f}"
                    if t.min_premium_usd is not None
                    else ""
                ),
            }
        )

    if filter_items:
        sections.append(
            {
                "title": "Trade selection",
                "items": filter_items,
            }
        )

    # 3) Structure / laddering behaviour
    structure_items: List[Dict[str, str]] = []

    if r.restrict_single_primary_call_per_expiry is not None:
        structure_items.append(
            {
                "label": "Single primary call per expiry",
                "value": _on_off(r.restrict_single_primary_call_per_expiry),
                "detail": "Prevents multiple overlapping main calls on same expiry.",
            }
        )

    if r.allow_multi_profile_laddering is not None:
        structure_items.append(
            {
                "label": "Multi-profile laddering",
                "value": _on_off(r.allow_multi_profile_laddering),
                "detail": "Allow conservative / moderate / aggressive legs together.",
            }
        )

    if r.use_synthetic_iv_and_skew is not None:
        structure_items.append(
            {
                "label": "Synthetic IV & skew engine",
                "value": _on_off(r.use_synthetic_iv_and_skew),
                "detail": "Use synthetic universe for IV/skew instead of raw quotes.",
            }
        )

    if structure_items:
        sections.append(
            {
                "title": "Structure & laddering",
                "items": structure_items,
            }
        )

    # Optional: a short “safety tagline”
    if cfg.mode == BacktestMode.TRAINING:
        safety_tagline = "Training mode: some safeguards may be relaxed for exploration."
    else:
        safety_tagline = "Live mode: safeguards enforced according to preset."

    return {
        "headline": headline,
        "subtitle": subtitle,
        "mode": cfg.mode.value,
        "preset": cfg.preset.value,
        "badges": badges,
        "sections": sections,
        "safety_tagline": safety_tagline,
    }


This returns a clean structure like:

summary = {
  "headline": "Training mode · Balanced",
  "subtitle": "Max margin: 60% · Max |net delta|: 3.50 · Delta range: 0.15 – 0.35 · DTE range: 3–21 days",
  "badges": [
    {"label": "Mode", "value": "training"},
    {"label": "Preset", "value": "BALANCED"},
    {"label": "Margin cap", "value": "ON"},
    ...
  ],
  "sections": [
    {"title": "Risk limits", "items": [...]},
    {"title": "Trade selection", "items": [...]},
    {"title": "Structure & laddering", "items": [...]},
  ],
  "safety_tagline": "Training mode: some safeguards may be relaxed for exploration."
}


Same function works for:

Backtest resolved config, and

Live agent current config (whatever you store for the running bot).

2. Jinja macro: render the rules summary box

Add a rules_summary.html (or put this in your main template and {% import %} it):

{# templates/partials/rules_summary.html #}
{% macro render_rules_summary(summary) %}
<div class="rules-summary-box" style="border:1px solid #333; border-radius:8px; padding:12px; margin-top:12px;">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
    <div>
      <div style="font-weight:bold;">{{ summary.headline }}</div>
      {% if summary.subtitle %}
        <div style="font-size: 0.9em; color:#888;">{{ summary.subtitle }}</div>
      {% endif %}
    </div>
    <div>
      {% for badge in summary.badges %}
        <span style="display:inline-block; background:#222; color:#eee; font-size:0.8em; padding:2px 6px; border-radius:999px; margin-left:4px;">
          {{ badge.label }}: <strong>{{ badge.value }}</strong>
        </span>
      {% endfor %}
    </div>
  </div>

  {% if summary.safety_tagline %}
    <div style="font-size:0.85em; color:#aaa; margin-bottom:8px;">
      {{ summary.safety_tagline }}
    </div>
  {% endif %}

  <div style="display:flex; flex-wrap:wrap; gap:12px;">
    {% for section in summary.sections %}
      <div style="flex:1 1 220px; min-width:220px;">
        <div style="font-weight:bold; margin-bottom:4px;">{{ section.title }}</div>
        <ul style="list-style:none; padding-left:0; margin:0;">
          {% for item in section.items %}
            <li style="margin-bottom:4px;">
              <span style="font-size:0.9em;">
                <strong>{{ item.label }}</strong>:
                <span>{{ item.value }}</span>
                {% if item.detail %}
                  <span style="color:#aaa;"> – {{ item.detail }}</span>
                {% endif %}
              </span>
            </li>
          {% endfor %}
        </ul>
      </div>
    {% endfor %}
  </div>
</div>
{% endmacro %}


Then in a page template:

{% import "partials/rules_summary.html" as rules_ui %}

<h3>Backtest configuration</h3>
{{ rules_ui.render_rules_summary(backtest_summary) }}

<h3>Live agent configuration</h3>
{{ rules_ui.render_rules_summary(live_summary) }}


Where backtest_summary / live_summary are the dicts built by build_rules_summary.

3. FastAPI integration examples
3.1. For backtest endpoint

In your backtests router:

# app/routers/backtests.py

from fastapi import APIRouter
from app.schemas.backtest import BacktestConfig, ResolvedBacktestConfig
from app.utils.rules_summary import build_rules_summary

router = APIRouter()


def apply_preset_and_overrides(cfg: BacktestConfig) -> ResolvedBacktestConfig:
    """
    You already have some logic like this; stub here for completeness.
    Takes BacktestConfig (preset + overrides) and returns ResolvedBacktestConfig.
    """
    # TODO: your actual preset logic here
    raise NotImplementedError


@router.post("/backtests/run")
async def run_backtest(payload: BacktestConfig):
    resolved: ResolvedBacktestConfig = apply_preset_and_overrides(payload)

    # run your actual backtest with `resolved`
    # result = backtest_engine.run(resolved)
    result = {"status": "ok", "placeholder": True}  # stub

    summary = build_rules_summary(resolved)

    return {
        "resolved_config": resolved,
        "rules_summary": summary,
        "result": result,
    }


Now the frontend can hit /backtests/run, use rules_summary both:

in the results page, and

in your main dashboard if you store the last-used config.

3.2. For live agent “current rules” box

Anywhere you know the current resolved config for the live bot:

# app/routers/dashboard.py

from fastapi import APIRouter, Request
from fastapi.templating import Jinja2Templates
from app.utils.rules_summary import build_rules_summary

router = APIRouter()
templates = Jinja2Templates(directory="templates")


@router.get("/dashboard")
async def dashboard(request: Request):
    # however you store current live config:
    live_resolved_config = await get_current_live_resolved_config()
    live_summary = build_rules_summary(live_resolved_config)

    # optional: last backtest summary
    last_backtest_summary = None
    last_backtest = await get_last_backtest_config()
    if last_backtest:
        last_backtest_summary = build_rules_summary(last_backtest)

    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "live_summary": live_summary,
            "backtest_summary": last_backtest_summary,
        },
    )


And in dashboard.html:

{% import "partials/rules_summary.html" as rules_ui %}

<h2>Live agent rules</h2>
{{ rules_ui.render_rules_summary(live_summary) }}

{% if backtest_summary %}
  <h2>Last backtest rules</h2>
  {{ rules_ui.render_rules_summary(backtest_summary) }}
{% endif %}