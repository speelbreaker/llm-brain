1. PositionTracker module (drop-in file)

Create a new file:
src/position_tracker.py with this content:

"""
Position tracking for bot-managed options positions.

Keeps an in-memory view of open and closed position chains so the web UI
can display PnL without scraping logs. Designed for *approximate* PnL;
if you need exchange-perfect numbers, extend this module to read full
trade history from Deribit.

This module is deliberately self-contained and has no side effects on import.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from threading import Lock
from typing import Dict, List, Optional, Literal, Any

Side = Literal["SHORT", "LONG"]
OptionType = Literal["CALL", "PUT"]
StrategyType = Literal["COVERED_CALL", "CASH_SECURED_PUT"]
ModeType = Literal["LIVE", "DRY_RUN"]


def _utc_now() -> datetime:
    return datetime.now(timezone.utc)


@dataclass
class PositionLeg:
    """Single executed leg within a position chain."""
    symbol: str
    underlying: str
    option_type: OptionType
    side: Side
    quantity: float
    entry_price: float
    entry_time: datetime
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None

    def is_open(self) -> bool:
        return self.exit_time is None


@dataclass
class PositionChain:
    """
    A chain of legs for a single bot-managed position.

    Example covered-call chain:
      - leg 1: short BTC 90k call (open)
      - leg 2: buy back 90k call, sell 95k call (roll)
      - leg 3: buy back 95k call (close)
    """
    position_id: str
    underlying: str
    option_type: OptionType
    strategy_type: StrategyType
    mode: ModeType
    exit_style: Optional[str] = None

    legs: List[PositionLeg] = field(default_factory=list)
    open_time: datetime = field(default_factory=_utc_now)
    close_time: Optional[datetime] = None
    realized_pnl: float = 0.0
    realized_pnl_pct: float = 0.0
    max_drawdown_pct: float = 0.0

    unrealized_pnl: float = 0.0
    unrealized_pnl_pct: float = 0.0

    def is_open(self) -> bool:
        return self.close_time is None

    @property
    def num_legs(self) -> int:
        return len(self.legs)

    @property
    def num_rolls(self) -> int:
        # one initial leg; rolls are additional opens
        return max(0, self.num_legs - 1)

    @property
    def symbol(self) -> str:
        return self.legs[-1].symbol if self.legs else ""


class PositionTracker:
    """
    Thread-safe tracker of bot-managed positions.

    Assumes linear USDC-settled options with contract_size=1.0.
    For inverse / other contract sizes, adjust `_pnl_for_leg`.
    """

    def __init__(self, notional_multiplier: float = 1.0) -> None:
        self._lock = Lock()
        self._chains: Dict[str, PositionChain] = {}
        self._notional_multiplier = float(notional_multiplier)

    # ------------------------------------------------------------------
    # Public API – called from execution / agent loop
    # ------------------------------------------------------------------

    def process_execution_result(self, result: Dict[str, Any]) -> None:
        """
        Update chains based on a single execution result.

        Expected shape (what execute_action/execute_actions already return):
          - result["status"]: "executed" | "simulated" | ...
          - result["action"]: "OPEN_COVERED_CALL" | "ROLL_COVERED_CALL" | "CLOSE_COVERED_CALL"
          - result["params"]: dict with symbol/from_symbol/to_symbol, size, underlying, etc.
          - result["orders"]: list with order dicts {symbol, size, price, ...}
          - result["underlying"] (optional)
          - result["strategy"]  (optional)
          - result["dry_run"]: bool
        """
        status = result.get("status")
        if status in {"error", "skipped"}:
            return

        action = str(result.get("action", ""))
        params = result.get("params", {}) or {}
        orders = result.get("orders", []) or []

        underlying = params.get("underlying") or result.get("underlying") or "?"
        strategy_type: StrategyType = "COVERED_CALL"   # for now
        option_type: OptionType = "CALL"               # for now
        mode: ModeType = "DRY_RUN" if result.get("dry_run", False) else "LIVE"
        exit_style = params.get("exit_style") or result.get("exit_style")

        # Helper: pick a price from orders; fall back to params["price"]
        def _extract_price(symbol_key: str) -> float:
            sym = params.get(symbol_key) or params.get("symbol")
            if sym:
                for o in orders:
                    if o.get("symbol") == sym and o.get("price") is not None:
                        return float(o["price"])
            for o in orders:
                if o.get("price") is not None:
                    return float(o["price"])
            return float(params.get("price", 0.0))

        # In this first version we support at most one chain per underlying
        position_id = f"{underlying}-{strategy_type}"
        now = _utc_now()

        with self._lock:
            chain = self._chains.get(position_id)

            # OPEN
            if action == "OPEN_COVERED_CALL":
                symbol = params.get("symbol") or (orders[0].get("symbol") if orders else "")
                size = float(params.get("size") or (orders[0].get("size", 0.0) if orders else 0.0))
                price = _extract_price("symbol")

                leg = PositionLeg(
                    symbol=symbol,
                    underlying=underlying,
                    option_type=option_type,
                    side="SHORT",
                    quantity=size,
                    entry_price=price,
                    entry_time=now,
                )
                chain = PositionChain(
                    position_id=position_id,
                    underlying=underlying,
                    option_type=option_type,
                    strategy_type=strategy_type,
                    mode=mode,
                    exit_style=exit_style,
                    legs=[leg],
                    open_time=now,
                )
                self._chains[position_id] = chain

            # ROLL
            elif action == "ROLL_COVERED_CALL":
                if chain is None:
                    return

                from_symbol = params.get("from_symbol") or ""
                to_symbol = params.get("to_symbol") or ""
                size = float(params.get("size") or (orders[0].get("size", 0.0) if orders else 0.0))

                # close old leg
                close_price = _extract_price("from_symbol")
                for leg in chain.legs:
                    if leg.is_open() and (not from_symbol or leg.symbol == from_symbol):
                        leg.exit_price = close_price
                        leg.exit_time = now
                        chain.realized_pnl += self._pnl_for_leg(leg)

                # open new leg
                open_price = _extract_price("to_symbol") or close_price
                new_leg = PositionLeg(
                    symbol=to_symbol or from_symbol,
                    underlying=underlying,
                    option_type=option_type,
                    side="SHORT",
                    quantity=size,
                    entry_price=open_price,
                    entry_time=now,
                )
                chain.legs.append(new_leg)

            # CLOSE
            elif action == "CLOSE_COVERED_CALL":
                if chain is None:
                    return
                symbol = params.get("symbol") or chain.symbol
                close_price = _extract_price("symbol")
                for leg in chain.legs:
                    if leg.is_open() and (not symbol or leg.symbol == symbol):
                        leg.exit_price = close_price
                        leg.exit_time = now
                        chain.realized_pnl += self._pnl_for_leg(leg)

                chain.close_time = now

            # Recompute unrealized PnL etc.
            if chain is not None:
                self._update_chain_unrealized(chain)

    def refresh_marks(self, client: Any) -> None:
        """
        Update mark prices/unrealized PnL for all open chains.

        `client` must have get_ticker(symbol) -> {"mark_price": float, ...}.
        """
        with self._lock:
            for chain in self._chains.values():
                if not chain.is_open():
                    continue
                # For now we just recompute based on entry prices; you can extend this
                # to pull mark_price per leg if you want.
                self._update_chain_unrealized(chain)

    # ------------------------------------------------------------------
    # Serialization helpers – used by web_app
    # ------------------------------------------------------------------

    def get_open_positions_payload(self) -> Dict[str, Any]:
        with self._lock:
            positions: List[Dict[str, Any]] = []
            for chain in self._chains.values():
                if not chain.is_open():
                    continue
                positions.append(self._chain_to_open_summary(chain))

            totals = {
                "positions_count": len(positions),
                "unrealized_pnl": float(sum(p["unrealized_pnl"] for p in positions)) if positions else 0.0,
                "unrealized_pnl_pct": float(sum(p["unrealized_pnl_pct"] for p in positions)) if positions else 0.0,
            }
            return {"positions": positions, "totals": totals}

    def get_closed_positions_payload(self) -> Dict[str, Any]:
        with self._lock:
            chains: List[Dict[str, Any]] = []
            for chain in self._chains.values():
                if chain.is_open():
                    continue
                chains.append(self._chain_to_closed_summary(chain))

            totals = {
                "chains_count": len(chains),
                "realized_pnl": float(sum(c["realized_pnl"] for c in chains)) if chains else 0.0,
                "realized_pnl_pct": float(sum(c["realized_pnl_pct"] for c in chains)) if chains else 0.0,
            }
            return {"chains": chains, "totals": totals}

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _pnl_for_leg(self, leg: PositionLeg, mark_price: Optional[float] = None) -> float:
        """
        Compute PnL in USD for a single leg.

        Assumes linear USDC-settled options with contract_size=1.0:
          SHORT: (entry - exit_or_mark) * qty
          LONG:  (exit_or_mark - entry) * qty
        """
        if mark_price is None:
            if leg.exit_price is None:
                return 0.0
            px2 = float(leg.exit_price)
        else:
            px2 = float(mark_price)

        px1 = float(leg.entry_price)
        qty = float(leg.quantity)
        direction = -1.0 if leg.side == "SHORT" else 1.0

        return (px1 - px2) * qty * self._notional_multiplier * direction

    def _update_chain_unrealized(self, chain: PositionChain) -> None:
        realized = chain.realized_pnl
        unrealized = 0.0

        for leg in chain.legs:
            if leg.is_open():
                # For now we use entry_price as a proxy for mark; extend if needed.
                unrealized += self._pnl_for_leg(leg, mark_price=leg.entry_price)

        chain.unrealized_pnl = unrealized
        if chain.legs:
            base = abs(chain.legs[0].entry_price * chain.legs[0].quantity * self._notional_multiplier) or 1.0
            chain.unrealized_pnl_pct = (realized + unrealized) / base * 100.0

    def _chain_to_open_summary(self, chain: PositionChain) -> Dict[str, Any]:
        dte = 0.0  # we don't know expiry yet; can be filled later
        return {
            "position_id": chain.position_id,
            "underlying": chain.underlying,
            "symbol": chain.symbol,
            "option_type": chain.option_type,
            "strategy_type": chain.strategy_type,
            "side": "SHORT",
            "quantity": chain.legs[-1].quantity if chain.legs else 0.0,
            "entry_price": chain.legs[0].entry_price if chain.legs else 0.0,
            "mark_price": chain.legs[-1].entry_price if chain.legs else 0.0,
            "unrealized_pnl": chain.unrealized_pnl,
            "unrealized_pnl_pct": chain.unrealized_pnl_pct,
            "entry_time": chain.open_time.isoformat(),
            "expiry": None,
            "dte": dte,
            "num_rolls": chain.num_rolls,
            "mode": chain.mode,
            "exit_style": chain.exit_style or "hold_to_expiry",
        }

    def _chain_to_closed_summary(self, chain: PositionChain) -> Dict[str, Any]:
        if chain.close_time is None:
            holding_days = 0.0
        else:
            holding_days = (chain.close_time - chain.open_time).total_seconds() / 86400.0

        return {
            "position_id": chain.position_id,
            "underlying": chain.underlying,
            "symbol": chain.symbol,
            "option_type": chain.option_type,
            "strategy_type": chain.strategy_type,
            "open_time": chain.open_time.isoformat(),
            "close_time": (chain.close_time or _utc_now()).isoformat(),
            "holding_days": holding_days,
            "num_legs": chain.num_legs,
            "num_rolls": chain.num_rolls,
            "realized_pnl": chain.realized_pnl,
            "realized_pnl_pct": chain.realized_pnl_pct,
            "max_drawdown_pct": chain.max_drawdown_pct,
            "mode": chain.mode,
            "exit_style": chain.exit_style or "hold_to_expiry",
            "note": None,
        }


# Global singleton used across the app
position_tracker = PositionTracker(notional_multiplier=1.0)


⚠️ PnL is approximate and assumes linear USDC options with contract size 1. You can tweak _pnl_for_leg if you want exact Deribit math.

2. Wire it into execution.py

At the top of src/execution.py, add:

from src.position_tracker import position_tracker


Then, at the end of _simulate_execution (just before return result), add:

    print(f"[DRY-RUN] {result.get('message', 'Simulated execution')}")
    try:
        position_tracker.process_execution_result(result)
    except Exception as e:
        print(f"[PositionTracker] error (simulated): {e}")
    return result


At the end of _execute_real (just before its return result), add:

    # ... after populating result["orders"] etc.
    try:
        position_tracker.process_execution_result(result)
    except Exception as e:
        print(f"[PositionTracker] error (real): {e}")
    return result


You don’t have to touch execute_actions() – it already calls execute_action() per element, and each call will now push into the tracker.

3. Add the API endpoints in web_app.py

At the imports near the top of src/web_app.py, add:

from src.position_tracker import position_tracker


Then add these endpoints (anywhere after the other /api/... routes):

@app.get("/api/positions/open")
def get_open_positions() -> JSONResponse:
    """Return open bot-managed positions for the UI."""
    payload = position_tracker.get_open_positions_payload()
    return JSONResponse(content=payload)


@app.get("/api/positions/closed")
def get_closed_positions() -> JSONResponse:
    """Return closed bot-managed chains with realized PnL."""
    payload = position_tracker.get_closed_positions_payload()
    return JSONResponse(content=payload)


Your frontend JS can then call these and render the tables we designed earlier.

4. Where is backtesting lab data stored?

Right now you effectively have three “layers” of data:

4.1. In-memory backtest status (what the UI shows)

The Backtest Manager (src/backtest/manager.py) keeps a _status object with:

live progress,

recent steps,

metrics,

recent chains, etc.

This lives only in memory and is exposed via the /api/backtest/status endpoint in src/web_app.py.

When you refresh the server or restart Replit, that in-memory state is gone.

There is no automatic CSV/JSON dump for normal UI backtests unless you explicitly enable training exports.

4.2. Training data exports

This is the only place where “proper data” is written to disk:

In src/backtest/manager.py there’s a helper:

def _export_training_data_if_enabled(...):
    from src.config import settings
    if not settings.save_training_data:
        return
    from pathlib import Path
    from .training_dataset import export_to_csv, export_to_jsonl, compute_dataset_stats

    data_dir = Path(settings.training_data_dir)  # default "data"
    data_dir.mkdir(parents=True, exist_ok=True)

    csv_path = data_dir / f"{base_name}.csv"
    jsonl_path = data_dir / f"{base_name}.jsonl"
    export_to_csv(examples, csv_path)
    export_to_jsonl(examples, jsonl_path)


Config knobs in src/config.py:

save_training_data: bool = False
training_data_dir: str = "data"


So:

If settings.save_training_data = True, and you run a backtest in the training / dataset mode (where it calls generate_training_data), you’ll get files like:

data/training_dataset_BTC_20240901_20251205_hold_to_expiry_20251205_143000.csv

data/training_dataset_BTC_...jsonl

Those contain the (state, action, reward) tuples and summary stats you can use for ML / RL.

If save_training_data=False (default), nothing from the lab is persisted except logs.

4.3. Logs

Text logs go into the logs/ directory (depending on how you configured logging_utils.py), but those are just log lines, not structured datasets.